name: Test Docker Configuration

# DÃ©clenche le workflow sur push et pull request vers main
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# Variables d'environnement globales
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job pour tester le build Docker
  docker-build-test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        # Teste les deux Dockerfiles
        dockerfile: [Dockerfile, Dockerfile.dev]
        
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”§ Build de l'image Docker (${{ matrix.dockerfile }})
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.dockerfile }}
          push: false
          tags: test-image:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job pour tester le fonctionnement de l'application
  docker-run-test:
    runs-on: ubuntu-latest
    needs: docker-build-test
    
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”§ Build de l'image de production
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          load: true
          tags: lazyapp-test:latest
          cache-from: type=gha

      - name: ğŸš€ Test du dÃ©marrage de l'application
        run: |
          # Lance le conteneur en arriÃ¨re-plan
          docker run -d --name test-app -p 3000:3000 lazyapp-test:latest
          
          # Attend que l'application dÃ©marre
          sleep 10
          
          # VÃ©rifie que l'application rÃ©pond
          curl -f http://localhost:3000 || exit 1
          
          # VÃ©rifie les logs pour s'assurer qu'il n'y a pas d'erreurs
          docker logs test-app
          
          # Nettoie
          docker stop test-app
          docker rm test-app

  # Job pour tester docker-compose
  docker-compose-test:
    runs-on: ubuntu-latest
    needs: docker-build-test
    
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ”§ Test Docker Compose (Production)
        run: |
          # Test du mode production
          docker compose up -d
          sleep 15
          
          # VÃ©rifie que l'application rÃ©pond
          curl -f http://localhost:3002 || exit 1
          
          # VÃ©rifie les logs
          docker compose logs
          
          # Nettoie
          docker compose down

      - name: ğŸ”§ Test Docker Compose (DÃ©veloppement)
        run: |
          # Test du mode dÃ©veloppement
          docker compose --profile dev up -d
          sleep 15
          
          # VÃ©rifie que l'application rÃ©pond
          curl -f http://localhost:3001 || exit 1
          
          # VÃ©rifie les logs
          docker compose --profile dev logs
          
          # Nettoie
          docker compose --profile dev down

  # Job pour le scan de sÃ©curitÃ©
  security-scan:
    runs-on: ubuntu-latest
    needs: docker-build-test
    
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”§ Build de l'image pour le scan
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          load: true
          tags: lazyapp-security-scan:latest
          cache-from: type=gha

      - name: ğŸ” Scan de sÃ©curitÃ© avec Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'lazyapp-security-scan:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: ğŸ“Š Upload des rÃ©sultats Trivy vers GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Job pour valider la configuration
  validate-config:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: âœ… Validation de la syntaxe Docker Compose
        run: |
          docker compose config

      - name: âœ… Validation des Dockerfiles
        run: |
          # Installe hadolint pour valider les Dockerfiles
          wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x hadolint
          
          # Valide les Dockerfiles
          ./hadolint Dockerfile
          ./hadolint Dockerfile.dev

      - name: ğŸ“‹ VÃ©rification des fichiers requis
        run: |
          # VÃ©rifie que tous les fichiers Docker sont prÃ©sents
          test -f Dockerfile || exit 1
          test -f Dockerfile.dev || exit 1
          test -f docker-compose.yml || exit 1
          test -f .dockerignore || exit 1
          
          echo "âœ… Tous les fichiers Docker sont prÃ©sents"

  # Job de rÃ©sumÃ©
  docker-test-summary:
    runs-on: ubuntu-latest
    needs: [docker-build-test, docker-run-test, docker-compose-test, security-scan, validate-config]
    if: always()
    
    steps:
      - name: ğŸ“Š RÃ©sumÃ© des tests Docker
        run: |
          echo "ğŸ³ Tests Docker terminÃ©s:"
          echo "âœ… Build des images: ${{ needs.docker-build-test.result }}"
          echo "âœ… Test de fonctionnement: ${{ needs.docker-run-test.result }}"
          echo "âœ… Test Docker Compose: ${{ needs.docker-compose-test.result }}"
          echo "âœ… Scan de sÃ©curitÃ©: ${{ needs.security-scan.result }}"
          echo "âœ… Validation config: ${{ needs.validate-config.result }}"

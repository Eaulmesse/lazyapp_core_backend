name: Test Docker Configuration

# Déclenche le workflow sur push et pull request vers main
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# Variables d'environnement globales
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job pour tester le build Docker
  docker-build-test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        # Teste les deux Dockerfiles
        dockerfile: [Dockerfile, Dockerfile.dev]
        
    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4

      - name: 🐳 Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔧 Build de l'image Docker (${{ matrix.dockerfile }})
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.dockerfile }}
          push: false
          tags: test-image:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job pour tester le fonctionnement de l'application
  docker-run-test:
    runs-on: ubuntu-latest
    needs: docker-build-test
    
    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4

      - name: 🐳 Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔧 Build de l'image de production
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          load: true
          tags: lazyapp-test:latest
          cache-from: type=gha

      - name: 🚀 Test du démarrage de l'application
        run: |
          # Lance le conteneur en arrière-plan
          docker run -d --name test-app -p 3000:3000 lazyapp-test:latest
          
          # Attend que l'application démarre
          sleep 10
          
          # Vérifie que l'application répond
          curl -f http://localhost:3000 || exit 1
          
          # Vérifie les logs pour s'assurer qu'il n'y a pas d'erreurs
          docker logs test-app
          
          # Nettoie
          docker stop test-app
          docker rm test-app

  # Job pour tester docker-compose
  docker-compose-test:
    runs-on: ubuntu-latest
    needs: docker-build-test
    
    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4

      - name: 🔧 Test Docker Compose (Production)
        run: |
          # Test du mode production
          docker compose up -d
          sleep 15
          
          # Vérifie que l'application répond
          curl -f http://localhost:3002 || exit 1
          
          # Vérifie les logs
          docker compose logs
          
          # Nettoie
          docker compose down

      - name: 🔧 Test Docker Compose (Développement)
        run: |
          # Test du mode développement
          docker compose --profile dev up -d
          sleep 15
          
          # Vérifie que l'application répond
          curl -f http://localhost:3001 || exit 1
          
          # Vérifie les logs
          docker compose --profile dev logs
          
          # Nettoie
          docker compose --profile dev down

  # Job pour le scan de sécurité
  security-scan:
    runs-on: ubuntu-latest
    needs: docker-build-test
    
    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4

      - name: 🐳 Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔧 Build de l'image pour le scan
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          load: true
          tags: lazyapp-security-scan:latest
          cache-from: type=gha

      - name: 🔍 Scan de sécurité avec Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'lazyapp-security-scan:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: 📊 Upload des résultats Trivy vers GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Job pour valider la configuration
  validate-config:
    runs-on: ubuntu-latest
    
    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4

      - name: ✅ Validation de la syntaxe Docker Compose
        run: |
          docker compose config

      - name: ✅ Validation des Dockerfiles
        run: |
          # Installe hadolint pour valider les Dockerfiles
          wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x hadolint
          
          # Valide les Dockerfiles
          ./hadolint Dockerfile
          ./hadolint Dockerfile.dev

      - name: 📋 Vérification des fichiers requis
        run: |
          # Vérifie que tous les fichiers Docker sont présents
          test -f Dockerfile || exit 1
          test -f Dockerfile.dev || exit 1
          test -f docker-compose.yml || exit 1
          test -f .dockerignore || exit 1
          
          echo "✅ Tous les fichiers Docker sont présents"

  # Job de résumé
  docker-test-summary:
    runs-on: ubuntu-latest
    needs: [docker-build-test, docker-run-test, docker-compose-test, security-scan, validate-config]
    if: always()
    
    steps:
      - name: 📊 Résumé des tests Docker
        run: |
          echo "🐳 Tests Docker terminés:"
          echo "✅ Build des images: ${{ needs.docker-build-test.result }}"
          echo "✅ Test de fonctionnement: ${{ needs.docker-run-test.result }}"
          echo "✅ Test Docker Compose: ${{ needs.docker-compose-test.result }}"
          echo "✅ Scan de sécurité: ${{ needs.security-scan.result }}"
          echo "✅ Validation config: ${{ needs.validate-config.result }}"
